<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="">
  
  <meta name="author" content="Steve Westenbroek, John Engott, Vic Kelson, Randall Hunt">
  <link rel="icon" href="../favicon.png">

  <title>kiss_random_number_generator.F90 &ndash; SWB2</title>

  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/pygments.css" rel="stylesheet">
  <link href="../css/font-awesome.min.css" rel="stylesheet">
  <link href="../css/bootstrap-toc.css" rel="stylesheet">
    <!-- <link href="../css/local.css" rel="stylesheet"> -->
  
  

  <script src="../js/jquery-2.1.3.min.js"></script>
  <script src="../js/svg-pan-zoom.min.js"></script>
  <script src="../js/bootstrap-toc.js"></script>

</head>

<body data-spy="scroll" data-target="#toc">

  <!-- Fixed navbar -->
  <nav class="navbar navbar-expand-lg fixed-top navbar-light bg-light">

    <a class="navbar-brand" href="../index.html">SWB2</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" navbar-light bg-light id="navbarText">
      <ul class="navbar-nav mr-auto">

        
          <li class="nav-item">
            <a class="nav-link" href="../page/index.html">User Guide</a>
          </li>
        

        
          <li class="nav-item">
            <a class="nav-link" href="../lists/modules.html">Modules</a>
          </li>
        

        

        
          <li class="nav-item">
            <a class="nav-link" href="../lists/procedures.html">Procedures</a>
          </li>
        

        
          <li class="nav-item">
            <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
          </li>
        


      </ul>
    </div>

    <form class="form-inline">
      <input class="form-control mr-sm-2" type="text" placeholder="Search">
      <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
    </form>
        <!-- <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Contents <span class="caret"></span></a>
            <ul class="dropdown-menu"> -->
          <!-- 
            
              <li><a href="../lists/files.html">Source Files</a></li>
            
          
          
            <li><a href="../lists/modules.html">Modules</a></li>
          
          
          
            <li><a href="../lists/procedures.html">Procedures</a></li>
          
          
            <li><a href="../lists/absint.html">Abstract Interfaces</a></li>
           
            <li><a href="../lists/types.html">Derived Types</a></li>
          
          
            <li><a href="../lists/programs.html">Programs</a></li>
          
        </ul> -->

      <!-- </div> -->
      <!--/.nav-collapse -->

  </nav>

  <div class="container">
    
  
  <div class="row">
    <h1>kiss_random_number_generator.F90
    <small>Source File</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="card">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title=" 0.3% of total for source files.">62 statements</a>
     </li>
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/kiss_random_number_generator.F90"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
  
     <li class="active">kiss_random_number_generator.F90</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>










<div class="card bg-primary">
  <!-- <div class="card-heading text-left"><h3 class="card-title"><a data-toggle="collapse" href="#mods-0">Modules</a></h3></div> -->
  <div class="card-header"><a data-toggle="collapse" href="#mods-0" aria-expanded="true" aria-controls="collapse-example" id="heading-example" class="d-block">
            <i class="fa fa-chevron-down pull-right"></i>Modules</a>
  </div>

  <div id="mods-0" class="card-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../module/kiss_random_number_generator.html">kiss_random_number_generator</a>
      
    </div>
  </div>
</div>

















<div class="card bg-primary">
  <div class="card-heading text-left"><h3 class="card-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../sourcefile/kiss_random_number_generator.f90.html#src">kiss_random_number_generator.F90</a>
  </div>
</div>



</div>

    </div>
    <div class="col-md-9" id='text'>
      
      <br>
    
      
      

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>










<div class="card bg-primary">
  <!-- <div class="card-heading text-left"><h3 class="card-title"><a data-toggle="collapse" href="#mods-1">Modules</a></h3></div> -->
  <div class="card-header"><a data-toggle="collapse" href="#mods-1" aria-expanded="true" aria-controls="collapse-example" id="heading-example" class="d-block">
            <i class="fa fa-chevron-down pull-right"></i>Modules</a>
  </div>

  <div id="mods-1" class="card-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../module/kiss_random_number_generator.html">kiss_random_number_generator</a>
      
    </div>
  </div>
</div>

















<div class="card bg-primary">
  <div class="card-heading text-left"><h3 class="card-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../sourcefile/kiss_random_number_generator.f90.html#src">kiss_random_number_generator.F90</a>
  </div>
</div>



    </section>
    <br class="visible-xs visible-sm hidden-md">

    <section>
      <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="hl"><pre><span></span><a name="ln-1"></a><span class="k">module </span><span class="n">kiss_random_number_generator</span>
<a name="ln-2"></a><span class="c">! period 5*2^1320480*(2^64-1)</span>
<a name="ln-3"></a>
<a name="ln-4"></a>  <span class="k">implicit none</span>
<a name="ln-5"></a>
<a name="ln-6"></a><span class="k">  </span><span class="kt">integer</span><span class="p">,</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">I8</span><span class="o">=</span><span class="mi">8</span>
<a name="ln-7"></a>  <span class="kt">integer</span><span class="p">,</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">R8</span><span class="o">=</span><span class="mi">8</span>
<a name="ln-8"></a>  <span class="kt">integer</span><span class="p">,</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">R16</span><span class="o">=</span><span class="mi">16</span>
<a name="ln-9"></a>
<a name="ln-10"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">Q</span><span class="p">(</span><span class="mi">20632</span><span class="p">)</span>
<a name="ln-11"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">carry</span><span class="o">=</span><span class="mi">36243678541_I8</span>
<a name="ln-12"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">xcng</span><span class="o">=</span><span class="mi">12367890123456_I8</span>
<a name="ln-13"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">xs</span><span class="o">=</span><span class="mi">521288629546311_I8</span>
<a name="ln-14"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">indx</span><span class="o">=</span><span class="mi">20633_I8</span>
<a name="ln-15"></a>
<a name="ln-16"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">I8_max</span> <span class="o">=</span> <span class="nb">huge</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
<a name="ln-17"></a>  <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">I8_min</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="nb">huge</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<a name="ln-18"></a>  <span class="kt">real</span><span class="p">(</span><span class="n">R16</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">I16_range</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="nb">huge</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span>
<a name="ln-19"></a>
<a name="ln-20"></a><span class="k">contains</span>
<a name="ln-21"></a>
<a name="ln-22"></a><span class="c">! original post found here:</span>
<a name="ln-23"></a><span class="c">! https://www.thecodingforums.com/threads/64-bit-kiss-rngs.673657/</span>
<a name="ln-24"></a>
<a name="ln-25"></a><span class="c">! 64-bit KISS RNGs</span>
<a name="ln-26"></a><span class="c">!</span>
<a name="ln-27"></a><span class="c">! Consistent with the Keep It Simple Stupid (KISS) principle,</span>
<a name="ln-28"></a><span class="c">! I have previously suggested 32-bit KISS Random Number</span>
<a name="ln-29"></a><span class="c">! Generators (RNGs) that seem to have been frequently adopted.</span>
<a name="ln-30"></a><span class="c">!</span>
<a name="ln-31"></a><span class="c">! Having had requests for 64-bit KISSes, and now that</span>
<a name="ln-32"></a><span class="c">! 64-bit integers are becoming more available, I will</span>
<a name="ln-33"></a><span class="c">! describe here a 64-bit KISS RNG, with comments on</span>
<a name="ln-34"></a><span class="c">! implementation for various languages, speed, periods</span>
<a name="ln-35"></a><span class="c">! and performance after extensive tests of randomness.</span>
<a name="ln-36"></a><span class="c">!</span>
<a name="ln-37"></a><span class="c">! This 64-bit KISS RNG has three components, each nearly</span>
<a name="ln-38"></a><span class="c">! good enough to serve alone. The components are:</span>
<a name="ln-39"></a><span class="c">! Multiply-With-Carry (MWC), period (2^121+2^63-1)</span>
<a name="ln-40"></a><span class="c">! Xorshift (XSH), period 2^64-1</span>
<a name="ln-41"></a><span class="c">! Congruential (CNG), period 2^64</span>
<a name="ln-42"></a><span class="c">!</span>
<a name="ln-43"></a><span class="c">! Compact C and Fortran listings are given below. They</span>
<a name="ln-44"></a><span class="c">! can be cut, pasted, compiled and run to see if, after</span>
<a name="ln-45"></a><span class="c">! 100 million calls, results agree with that provided</span>
<a name="ln-46"></a><span class="c">! by theory, assuming the default seeds.</span>
<a name="ln-47"></a><span class="c">!</span>
<a name="ln-48"></a><span class="c">! Users may want to put the content in other forms, and,</span>
<a name="ln-49"></a><span class="c">! for general use, provide means to set the 250 seed bits</span>
<a name="ln-50"></a><span class="c">! required in the variables x,y,z (64 bits) and c (58 bits)</span>
<a name="ln-51"></a><span class="c">! that have been given default values in the test versions.</span>
<a name="ln-52"></a><span class="c">!</span>
<a name="ln-53"></a><span class="c">! The C version uses #define macros to enumerate the few</span>
<a name="ln-54"></a><span class="c">! instructions that MWC, XSH and CNG require. The KISS</span>
<a name="ln-55"></a><span class="c">! macro adds MWC+XSH+CNG mod 2^64, so that KISS can be</span>
<a name="ln-56"></a><span class="c">! inserted at any place in a C program where a random 64-bit</span>
<a name="ln-57"></a><span class="c">! integer is required.</span>
<a name="ln-58"></a><span class="c">! Fortran&#39;s requirement that integers be signed makes the</span>
<a name="ln-59"></a><span class="c">! necessary code more complicated, hence a function KISS().</span>
<a name="ln-60"></a><span class="c">!</span>
<a name="ln-61"></a><span class="c">! C version; test by invoking macro KISS 100 million times</span>
<a name="ln-62"></a><span class="c">! -----------------------------------------------------------------</span>
<a name="ln-63"></a><span class="c">! #include &lt;stdio.h&gt;</span>
<a name="ln-64"></a><span class="c">!</span>
<a name="ln-65"></a><span class="c">! static unsigned long long</span>
<a name="ln-66"></a><span class="c">! x=1234567890987654321ULL,c=123456123456123456ULL,</span>
<a name="ln-67"></a><span class="c">! y=362436362436362436ULL,z=1066149217761810ULL,t;</span>
<a name="ln-68"></a><span class="c">!</span>
<a name="ln-69"></a><span class="c">! #define MWC (t=(x&lt;&lt;58)+c, c=(x&gt;&gt;6), x+=t, c+=(x&lt;t), x)</span>
<a name="ln-70"></a><span class="c">! #define XSH ( y^=(y&lt;&lt;13), y^=(y&gt;&gt;17), y^=(y&lt;&lt;43) )</span>
<a name="ln-71"></a><span class="c">! #define CNG ( z=6906969069LL*z+1234567 )</span>
<a name="ln-72"></a><span class="c">! #define KISS (MWC+XSH+CNG)</span>
<a name="ln-73"></a><span class="c">!</span>
<a name="ln-74"></a><span class="c">! int main(void)</span>
<a name="ln-75"></a><span class="c">! {int i;</span>
<a name="ln-76"></a><span class="c">! for(i=0;i&lt;100000000;i++) t=KISS;</span>
<a name="ln-77"></a><span class="c">! (t==1666297717051644203ULL) ?</span>
<a name="ln-78"></a><span class="c">! printf(&quot;100 million uses of KISS OK&quot;):</span>
<a name="ln-79"></a><span class="c">! printf(&quot;Fail&quot;);</span>
<a name="ln-80"></a><span class="c">! }</span>
<a name="ln-81"></a><span class="c">!</span>
<a name="ln-82"></a><span class="c">! ---------------------------------------------------------------</span>
<a name="ln-83"></a><span class="c">! Fortran version; test by calling KISS() 100 million times</span>
<a name="ln-84"></a><span class="c">! ---------------------------------------------------------------</span>
<a name="ln-85"></a><span class="c">! program testkiss</span>
<a name="ln-86"></a><span class="c">! implicit integer*8(a-z)</span>
<a name="ln-87"></a><span class="c">! do i=1,100000000; t=KISS(); end do</span>
<a name="ln-88"></a><span class="c">! if(t.eq.1666297717051644203_8) then</span>
<a name="ln-89"></a><span class="c">! print*,&quot;100 million calls to KISS() OK&quot;</span>
<a name="ln-90"></a><span class="c">! else; print*,&quot;Fail&quot;</span>
<a name="ln-91"></a><span class="c">! end if; end</span>
<a name="ln-92"></a><span class="c">!</span>
<a name="ln-93"></a><span class="c">! function KISS()</span>
<a name="ln-94"></a><span class="c">! implicit integer*8(a-z)</span>
<a name="ln-95"></a><span class="c">! data x,y,z,c /1234567890987654321_8, 362436362436362436_8,&amp;</span>
<a name="ln-96"></a><span class="c">! 1066149217761810_8, 123456123456123456_8/</span>
<a name="ln-97"></a><span class="c">! save x,y,z,c</span>
<a name="ln-98"></a><span class="c">! m(x,k)=ieor(x,ishft(x,k)) !statement function</span>
<a name="ln-99"></a><span class="c">! s(x)=ishft(x,-63) !statement function</span>
<a name="ln-100"></a><span class="c">! t=ishft(x,58)+c</span>
<a name="ln-101"></a><span class="c">! if(s(x).eq.s(t)) then; c=ishft(x,-6)+s(x)</span>
<a name="ln-102"></a><span class="c">! else; c=ishft(x,-6)+1-s(x+t); endif</span>
<a name="ln-103"></a><span class="c">! x=t+x</span>
<a name="ln-104"></a><span class="c">! y=m(m(m(y,13_8),-17_8),43_8)</span>
<a name="ln-105"></a><span class="c">! z=6906969069_8*z+1234567</span>
<a name="ln-106"></a><span class="c">! KISS=x+y+z</span>
<a name="ln-107"></a><span class="c">! return; end</span>
<a name="ln-108"></a><span class="c">! ---------------------------------------------------------------</span>
<a name="ln-109"></a><span class="c">!</span>
<a name="ln-110"></a><span class="c">! Output from using the macro KISS or the function KISS()	is</span>
<a name="ln-111"></a><span class="c">! MWC+XSH+CNG mod 2^64.</span>
<a name="ln-112"></a><span class="c">!</span>
<a name="ln-113"></a><span class="c">! CNG is easily implemented on machines with 64-bit integers,</span>
<a name="ln-114"></a><span class="c">! as arithmetic is automatically mod 2^64, whether integers</span>
<a name="ln-115"></a><span class="c">! are considered signed or unsigned. The CNG statement is</span>
<a name="ln-116"></a><span class="c">! z=6906969069*z+1234567.</span>
<a name="ln-117"></a><span class="c">! When I established the lattice structure of congruential</span>
<a name="ln-118"></a><span class="c">! generators in the 60&#39;s, a search produced 69069 as an easy-</span>
<a name="ln-119"></a><span class="c">! to-remember multiplier with nearly cubic lattices in 2,3,4,5-</span>
<a name="ln-120"></a><span class="c">! space, so I tried concatenating, using 6906969069 as</span>
<a name="ln-121"></a><span class="c">! my first test multiplier. Remarkably---a seemingly one in many</span>
<a name="ln-122"></a><span class="c">! hundreds chance---it turned out to also have excellent lattice</span>
<a name="ln-123"></a><span class="c">! structure in 2,3,4,5-space, so that&#39;s the one chosen.</span>
<a name="ln-124"></a><span class="c">! (I doubt if lattice structure of CNG has much influence on the</span>
<a name="ln-125"></a><span class="c">! composite 64-bit KISS produced via MWC+XSH+CNG mod 2^64.)</span>
<a name="ln-126"></a><span class="c">!</span>
<a name="ln-127"></a><span class="c">!</span>
<a name="ln-128"></a><span class="c">! XSH, the Xorshift component, described in</span>
<a name="ln-129"></a><span class="c">! www.jstatsoft.org/v08/i14/paper</span>
<a name="ln-130"></a><span class="c">! uses three invocations of an integer &quot;xor&quot;ed with a shifted</span>
<a name="ln-131"></a><span class="c">! version of itself.</span>
<a name="ln-132"></a><span class="c">! The XSH component used for this KISS is, in C notation:</span>
<a name="ln-133"></a><span class="c">! y^=(y&lt;&lt;13); y^=(y&gt;&gt;17); y^=(y&lt;&lt;43)</span>
<a name="ln-134"></a><span class="c">! with Fortran equivalents y=ieor(y,ishft(y,13)), etc., although</span>
<a name="ln-135"></a><span class="c">! this can be effected by a Fortran statement function:</span>
<a name="ln-136"></a><span class="c">! f(y,k)=ieor(y,ishft(y,k))</span>
<a name="ln-137"></a><span class="c">! y=f(f(f(y,13),-17),43)</span>
<a name="ln-138"></a><span class="c">! As with lattice structure, choice of the triple 13,-17,43 is</span>
<a name="ln-139"></a><span class="c">! probably of no particular importance; any one of the 275 full-</span>
<a name="ln-140"></a><span class="c">! period triples listed in the above article is likely to provide</span>
<a name="ln-141"></a><span class="c">! a satisfactory component XSH for the composite MWC+XSH+CNG.</span>
<a name="ln-142"></a><span class="c">!</span>
<a name="ln-143"></a><span class="c">! The choice of multiplier &#39;a&#39; for the multiply-with-carry (MWC)</span>
<a name="ln-144"></a><span class="c">! component of KISS is not so easily made. In effect, a multiply-</span>
<a name="ln-145"></a><span class="c">! with-carry sequence has a current value x and current &quot;carry&quot; c,</span>
<a name="ln-146"></a><span class="c">! and from each given x,c a new x,c pair is constructed by forming</span>
<a name="ln-147"></a><span class="c">! t=a*x+c, then x=t mod b=2^64 and c=floor(t/b).</span>
<a name="ln-148"></a><span class="c">! This is easily implemented for 32-bit computers that permit</span>
<a name="ln-149"></a><span class="c">! forming a*t+c in 64 bits, from which the new x is the bottom and</span>
<a name="ln-150"></a><span class="c">! the new c the top 32-bits.</span>
<a name="ln-151"></a><span class="c">!</span>
<a name="ln-152"></a><span class="c">! When a,x and c are 64-bits, not many computers seem to have an easy</span>
<a name="ln-153"></a><span class="c">! way to form t=a*x+c in 128 bits, then extract the top and bottom</span>
<a name="ln-154"></a><span class="c">! 64-bit segments. For that reason, special choices for &#39;a&#39; are</span>
<a name="ln-155"></a><span class="c">! needed among those that satisfy the general requirement that</span>
<a name="ln-156"></a><span class="c">! p=a*b-1 is a prime for which b=2^64 has order (p-1)/2.</span>
<a name="ln-157"></a><span class="c">!</span>
<a name="ln-158"></a><span class="c">! My choice---and the only one of this form---is a=2^58+1. Then the</span>
<a name="ln-159"></a><span class="c">! top 64 bits of an imagined 128-bit t=a*x+c may be obtained as</span>
<a name="ln-160"></a><span class="c">! (using C notation) (x&gt;&gt;6)+ 1 or 0, depending</span>
<a name="ln-161"></a><span class="c">! on whether the 64-bit parts of (x&lt;&lt;58)+c+x cause an overflow.</span>
<a name="ln-162"></a><span class="c">! Since (x&lt;&lt;58)+c cannot itself cause overflow (c will always be &lt;a),</span>
<a name="ln-163"></a><span class="c">! we get the carry as c=(x&gt;&gt;6) plus overflow from (x&lt;&lt;58)+x.</span>
<a name="ln-164"></a><span class="c">!</span>
<a name="ln-165"></a><span class="c">! This is easily done in C with unsigned integers, using a different</span>
<a name="ln-166"></a><span class="c">! kind of &#39;t&#39;: t=(x&lt;&lt;58)+c; c=(x&gt;&gt;6); x=t+x; c=c+(x&lt;t);</span>
<a name="ln-167"></a><span class="c">! For Fortran and others that permit only signed integers, more work</span>
<a name="ln-168"></a><span class="c">! is needed.</span>
<a name="ln-169"></a><span class="c">! Equivalent mod 2^64 versions of t=(x&lt;&lt;58)+c and c=(x&gt;&gt;6) are easy,</span>
<a name="ln-170"></a><span class="c">! and if s(x) represents (x&gt;&gt;63) in C or ishft(x,-66) in Fortran,</span>
<a name="ln-171"></a><span class="c">! then for signed integers, the new carry c comes from the rule</span>
<a name="ln-172"></a><span class="c">! if s(x) equals s(t) then c=(x&gt;&gt;6)+s(x) else c=(x&gt;&gt;6)+1-s(x+t)</span>
<a name="ln-173"></a><span class="c">!</span>
<a name="ln-174"></a><span class="c">! Speed:</span>
<a name="ln-175"></a><span class="c">! A C version of this KISS RNG takes 18 nanosecs for each</span>
<a name="ln-176"></a><span class="c">! 64-bit random number on my desktop (Vista) PC, thus</span>
<a name="ln-177"></a><span class="c">! producing KISSes at a rate exceeding 55 million per second.</span>
<a name="ln-178"></a><span class="c">! Fortran or other integers-must-be-signed compilers might get</span>
<a name="ln-179"></a><span class="c">! &quot;only&quot; around 40 million per second.</span>
<a name="ln-180"></a><span class="c">!</span>
<a name="ln-181"></a><span class="c">! Setting seeds:</span>
<a name="ln-182"></a><span class="c">! Use of KISS or KISS() as a general 64-bit RNG requires specifying</span>
<a name="ln-183"></a><span class="c">! 3*64+58=250 bits for seeds, 64 bits each for x,y,z and 58 for c,</span>
<a name="ln-184"></a><span class="c">! resulting in a composite sequence with period around 2^250.</span>
<a name="ln-185"></a><span class="c">! The actual period is</span>
<a name="ln-186"></a><span class="c">! (2^250+2^192+2^64-2^186-2^129)/6 ~= 2^(247.42) or 10^(74.48).</span>
<a name="ln-187"></a><span class="c">! We &quot;lose&quot; 1+1.58=2.58 bits from maximum possible period, one bit</span>
<a name="ln-188"></a><span class="c">! because b=2^64, a square, cannot be a primitive root of p=ab-1,</span>
<a name="ln-189"></a><span class="c">! so the best possible order for b is (p-1)/2.</span>
<a name="ln-190"></a><span class="c">! The periods of MWC and XSH have gcd 3=2^1.58, so another 1.58</span>
<a name="ln-191"></a><span class="c">! bits are &quot;lost&quot; from the best possible period we could expect</span>
<a name="ln-192"></a><span class="c">! from 250 seed bits.</span>
<a name="ln-193"></a><span class="c">!</span>
<a name="ln-194"></a><span class="c">! Some users may think 250 seed bits are an unreasonable requirement.</span>
<a name="ln-195"></a><span class="c">! A good seeding procedure might be to assume the default seed</span>
<a name="ln-196"></a><span class="c">! values then let the user choose none, one, two,..., or all</span>
<a name="ln-197"></a><span class="c">! of x,y,z, and c to be reseeded.</span>
<a name="ln-198"></a><span class="c">!</span>
<a name="ln-199"></a><span class="c">! Tests:</span>
<a name="ln-200"></a><span class="c">! Latest tests in The Diehard Battery, available at</span>
<a name="ln-201"></a><span class="c">! http://i.cs.hku.hk/~diehard/</span>
<a name="ln-202"></a><span class="c">! were applied extensively. Those tests that specifically required</span>
<a name="ln-203"></a><span class="c">! 32-bit integers were applied to the leftmost 32 bits</span>
<a name="ln-204"></a><span class="c">! (e,g, KISS&gt;&gt;32;), then to the middle 32-bits ((KISS&lt;&lt;16)&gt;&gt;32;)</span>
<a name="ln-205"></a><span class="c">! then to the rightmost 32 bits, ( (KISS&lt;&lt;32)&gt;&gt;32).</span>
<a name="ln-206"></a><span class="c">! There were no extremes in the more than 700 p-values returned</span>
<a name="ln-207"></a><span class="c">! by the tests, nor indeed for similar tests applied to just two of the</span>
<a name="ln-208"></a><span class="c">! KISS components: MWC+XSH, then MWC+CNG, then XSH+CNG.</span>
<a name="ln-209"></a><span class="c">!</span>
<a name="ln-210"></a><span class="c">! The simplicity, speed, period around 2^250 and performance on</span>
<a name="ln-211"></a><span class="c">! tests of randomness---as well as ability to produce exactly</span>
<a name="ln-212"></a><span class="c">! the same 64-bit patterns, whether considered signed or unsigned</span>
<a name="ln-213"></a><span class="c">! integers---make this 64-bit KISS well worth considering for</span>
<a name="ln-214"></a><span class="c">! adoption or adaption to languages other than C or Fortran,</span>
<a name="ln-215"></a><span class="c">! as has been done for 32-bit KISSes.</span>
<a name="ln-216"></a><span class="c">!</span>
<a name="ln-217"></a><span class="c">! George Marsaglia</span>
<a name="ln-218"></a>
<a name="ln-219"></a>
<a name="ln-220"></a><span class="c">!   from</span>
<a name="ln-221"></a><span class="c">!   https://www.thecodingforums.com/threads/superkiss-for-32-and-64-bit-rngs-in-both-c-and-fortran.706893/</span>
<a name="ln-222"></a>
<a name="ln-223"></a><span class="c">!   On Nov 3 I posted</span>
<a name="ln-224"></a><span class="c">!</span>
<a name="ln-225"></a><span class="c">!   RNGs: A Super KISS sci.math, comp.lang.c, sci.crypt</span>
<a name="ln-226"></a><span class="c">!</span>
<a name="ln-227"></a><span class="c">!   a KISS (Keep-It-Simple-Stupid) RNG combining,</span>
<a name="ln-228"></a><span class="c">!   by addition mod 2^32, three simple RNGs:</span>
<a name="ln-229"></a><span class="c">!   CMWC(Complementary-Multiply-With-Carry)+CNG(Congruential)</span>
<a name="ln-230"></a><span class="c">!   +XS(Xorshift)</span>
<a name="ln-231"></a><span class="c">!   with resulting period greater than 10^402575.</span>
<a name="ln-232"></a><span class="c">!</span>
<a name="ln-233"></a><span class="c">!   The extreme period comes from finding a prime p=a*b^r+1 for</span>
<a name="ln-234"></a><span class="c">!   which the order of b has magnitude near p-1, then use</span>
<a name="ln-235"></a><span class="c">!   the CMWC method, the mathematics of which I outline here:</span>
<a name="ln-236"></a><span class="c">!</span>
<a name="ln-237"></a><span class="c">!   Let Z be the set of all &quot;vectors&quot; of the form</span>
<a name="ln-238"></a><span class="c">!   [x_1,...,x_r;c] with 0&lt;=x_i&lt;b and 0&lt;=c&lt;a.</span>
<a name="ln-239"></a><span class="c">!   Then Z has ab^r elements, and if the function f() on Z is</span>
<a name="ln-240"></a><span class="c">!   f([x_1,x2,...,x_r;c])=</span>
<a name="ln-241"></a><span class="c">!   [x_2,...,x_r,b-1-(t mod b);trunc((t/b)], t=a*x_1+c</span>
<a name="ln-242"></a><span class="c">!   then f() has an inverse on Z: for each z in Z there is exactly</span>
<a name="ln-243"></a><span class="c">!   one w in Z for which f(w)=z:</span>
<a name="ln-244"></a><span class="c">!   f^{-1}([x_1,x2,...,x_r;c])=</span>
<a name="ln-245"></a><span class="c">!   [trunc((v/a),x_1,...,x_{r-1}; v mod a], v=cb+(b-1)-x_r</span>
<a name="ln-246"></a><span class="c">!</span>
<a name="ln-247"></a><span class="c">!   Thus a directed graph based on z-&gt;f(z) will consist only</span>
<a name="ln-248"></a><span class="c">!   of disjoint loops of size s=order(b,p) and there will be</span>
<a name="ln-249"></a><span class="c">!   L=ab^r/s such loops.</span>
<a name="ln-250"></a><span class="c">!</span>
<a name="ln-251"></a><span class="c">!   A random uniform choice of z from Z is equally likely to</span>
<a name="ln-252"></a><span class="c">!   fall in any one of the L loops, and then each &quot;vector&quot; in</span>
<a name="ln-253"></a><span class="c">!   the sequence obtained by iterating f:</span>
<a name="ln-254"></a><span class="c">!   f(z), f(f(z)), f(f(f(z))),...</span>
<a name="ln-255"></a><span class="c">!   will have a uniform distribution over that loop, and the sequence</span>
<a name="ln-256"></a><span class="c">!   determined by taking the r&#39;th element from each &quot;vector&quot;,</span>
<a name="ln-257"></a><span class="c">!   (the output of the CMWC RNG) will be periodic with period</span>
<a name="ln-258"></a><span class="c">!   the order of b for the prime p=ab^r+1, and that sequence</span>
<a name="ln-259"></a><span class="c">!   will produce, in reverse order, the base-b expansion of a</span>
<a name="ln-260"></a><span class="c">!   rational k/p for some k determined by choice of the seed z.</span>
<a name="ln-261"></a><span class="c">!</span>
<a name="ln-262"></a><span class="c">!   For that Nov 3 post, I had found that the order of b=2^32</span>
<a name="ln-263"></a><span class="c">!   for the prime p=7010176*b^41790+1 is 54767*2^1337279, about</span>
<a name="ln-264"></a><span class="c">!   10^402566, thus providing an easily-implemented</span>
<a name="ln-265"></a><span class="c">!   KISS=CMWC+CNG+XS RNG with immense period and</span>
<a name="ln-266"></a><span class="c">!   excellent performance on tests of randomness.</span>
<a name="ln-267"></a><span class="c">!</span>
<a name="ln-268"></a><span class="c">!   That easy implementation required carrying out the essential</span>
<a name="ln-269"></a><span class="c">!   parts of the CMWC function f(): form t=7010176*x+c in 64 bits,</span>
<a name="ln-270"></a><span class="c">!   extract the top 32 bits for the new c, the bottom 32 for</span>
<a name="ln-271"></a><span class="c">!   the new x---easy to do in C, not easy in Fortran.</span>
<a name="ln-272"></a><span class="c">!   And if we want 64-bit random numbers, with B=2^64, our prime</span>
<a name="ln-273"></a><span class="c">!   becomes 7010176*B^20985+1, for which the period of B is</span>
<a name="ln-274"></a><span class="c">!   54767*2^1337278, still immense, but in C, with 64-bit x,c</span>
<a name="ln-275"></a><span class="c">!   there seems no easy way to form t=7010176*x+c in 128 bits,</span>
<a name="ln-276"></a><span class="c">!   then extract the top and bottom 64 bit halves.</span>
<a name="ln-277"></a><span class="c">!</span>
<a name="ln-278"></a><span class="c">!   So base b=2^32 works for C but not Fortran,</span>
<a name="ln-279"></a><span class="c">!   and base B=2^64 works for neither C nor Fortran.</span>
<a name="ln-280"></a><span class="c">!</span>
<a name="ln-281"></a><span class="c">!   I offer here is a prime that provides CMWC RNGs for both</span>
<a name="ln-282"></a><span class="c">!   32- and 64-bits, and for both C and Fortran, and with</span>
<a name="ln-283"></a><span class="c">!   equally massive periods, again greater than 2^(1.3million):</span>
<a name="ln-284"></a><span class="c">!</span>
<a name="ln-285"></a><span class="c">!   p=640*b^41265+1 = 2748779069440*B^20632+1 = 5*2^1320487+1.</span>
<a name="ln-286"></a><span class="c">!</span>
<a name="ln-287"></a><span class="c">!   That prime came from the many who have dedicated their</span>
<a name="ln-288"></a><span class="c">!   efforts and computer time to prime searches. After some</span>
<a name="ln-289"></a><span class="c">!   three weeks of dedicated computer time using pfgw with</span>
<a name="ln-290"></a><span class="c">!   scrypt, I found the orders of b and B:</span>
<a name="ln-291"></a><span class="c">!   5*2^1320481 for b=2^32, 5*2^1320480 for B=2^64.</span>
<a name="ln-292"></a><span class="c">!</span>
<a name="ln-293"></a><span class="c">!   It is the choice of the &quot;a&quot; that makes it feasible to get</span>
<a name="ln-294"></a><span class="c">!   the top and bottom valves of t=a*x+c, yet stay within the</span>
<a name="ln-295"></a><span class="c">!   integer sizes the C or Fortran compilers are set for.</span>
<a name="ln-296"></a><span class="c">!   In the above prime: a=640=2^9+2^7 for b=2^32 and</span>
<a name="ln-297"></a><span class="c">!   a=2748779069440=2^41+2^39 for B=2^64.</span>
<a name="ln-298"></a><span class="c">!   Thus, for example with b=2^32 and using only 32-bit C code,</span>
<a name="ln-299"></a><span class="c">!   with a supposed 128-bit t=(2^9+2^7)*x+c, the top and bottom</span>
<a name="ln-300"></a><span class="c">!   32-bits of t may be obtained by setting, say,</span>
<a name="ln-301"></a><span class="c">!   h=(c&amp;1); z=(x&lt;&lt;9)&gt;&gt;1 + (x&lt;&lt;7)&gt;&gt;1 + c&gt;&gt;1;</span>
<a name="ln-302"></a><span class="c">!   then the top half of that t would be</span>
<a name="ln-303"></a><span class="c">!   c=(x&gt;&gt;23)+(x&gt;&gt;25)+(z&gt;&gt;31);</span>
<a name="ln-304"></a><span class="c">!   and the bottom half, before being complemented, would be</span>
<a name="ln-305"></a><span class="c">!   x=(z&lt;&lt;1)+h;</span>
<a name="ln-306"></a><span class="c">!</span>
<a name="ln-307"></a><span class="c">!   When B=2^64 we need only change to</span>
<a name="ln-308"></a><span class="c">!   h=(c&amp;1); z=(x&lt;&lt;41)&gt;&gt;1 + (x&lt;&lt;39)&gt;&gt;1 + c&gt;&gt;1;</span>
<a name="ln-309"></a><span class="c">!   c=(x&gt;&gt;23)+(x&gt;&gt;25)+(z&gt;&gt;63);</span>
<a name="ln-310"></a><span class="c">!</span>
<a name="ln-311"></a><span class="c">!   These C operations all have Fortran equivalents, and will</span>
<a name="ln-312"></a><span class="c">!   produce the required bit patterns, whether integers are</span>
<a name="ln-313"></a><span class="c">!   considered signed or unsigned. (In C, one must make sure</span>
<a name="ln-314"></a><span class="c">!   that the &gt;&gt; operation performs a logical right shift,</span>
<a name="ln-315"></a><span class="c">!   perhaps best done via &quot;unsigned&quot; declarations.)</span>
<a name="ln-316"></a><span class="c">!</span>
<a name="ln-317"></a><span class="c">!   The CMWC z &quot;vector&quot; elements [x_1,x_2,...,x_r] are kept in</span>
<a name="ln-318"></a><span class="c">!   an array, Q[] in C, Q() in Fortran, with a separate current</span>
<a name="ln-319"></a><span class="c">!   &quot;carry&quot;. This is all spelled out in the following examples:</span>
<a name="ln-320"></a><span class="c">!   code for 32- and 64-bit SuperKiss RNGs for C and Fortran.</span>
<a name="ln-321"></a><span class="c">!</span>
<a name="ln-322"></a><span class="c">!   Note that in these sample listings, the Q array is seeded</span>
<a name="ln-323"></a><span class="c">!   by CNG+XS, based on the seed values specified in the</span>
<a name="ln-324"></a><span class="c">!   initial declarations. For many simulation studies, the</span>
<a name="ln-325"></a><span class="c">!   73 bits needed to seed the initial xcng, xs and carry&lt;a</span>
<a name="ln-326"></a><span class="c">!   for the 32-bit version, or 169 bits needed for the 64-bit</span>
<a name="ln-327"></a><span class="c">!   version, may be adequate.</span>
<a name="ln-328"></a><span class="c">!   But more demanding applications may require a significant</span>
<a name="ln-329"></a><span class="c">!   portion of the &gt;1.3 million seed bits that Q requires.</span>
<a name="ln-330"></a><span class="c">!   See text and comments from the Nov 3 posting.</span>
<a name="ln-331"></a><span class="c">!</span>
<a name="ln-332"></a><span class="c">!   I am indebted to an anonymous mecej4 for providing the basic</span>
<a name="ln-333"></a><span class="c">!   form and KIND declarations of the Fortran versions.</span>
<a name="ln-334"></a><span class="c">!</span>
<a name="ln-335"></a><span class="c">!   Please let me and other readers know if the results are not</span>
<a name="ln-336"></a><span class="c">!   as specified when run with your compilers, or if you can</span>
<a name="ln-337"></a><span class="c">!   provide equivalent versions in other programming languages.</span>
<a name="ln-338"></a><span class="c">!</span>
<a name="ln-339"></a><span class="c">!   George Marsaglia</span>
<a name="ln-340"></a><span class="c">!</span>
<a name="ln-341"></a><span class="c">!   --------------------------------------------------------</span>
<a name="ln-342"></a><span class="c">!   Here is SUPRKISS64.c, the immense-period 64-bit RNG. I</span>
<a name="ln-343"></a><span class="c">!   invite you to cut, paste, compile and run to see if you</span>
<a name="ln-344"></a><span class="c">!   get the result I do. It should take around 20 seconds.</span>
<a name="ln-345"></a><span class="c">!   --------------------------------------------------------</span>
<a name="ln-346"></a><span class="c">!   /* SUPRKISS64.c, period 5*2^1320480*(2^64-1) */</span>
<a name="ln-347"></a><span class="c">!   #include &lt;stdio.h&gt;</span>
<a name="ln-348"></a><span class="c">!   static unsigned long long Q[20632],carry=36243678541LL,</span>
<a name="ln-349"></a><span class="c">!   xcng=12367890123456LL,xs=521288629546311LL,indx=20632;</span>
<a name="ln-350"></a><span class="c">!</span>
<a name="ln-351"></a><span class="c">!   #define CNG ( xcng=6906969069LL*xcng+123 )</span>
<a name="ln-352"></a><span class="c">!   #define XS ( xs^=xs&lt;&lt;13,xs^=xs&gt;&gt;17,xs^=xs&lt;&lt;43 )</span>
<a name="ln-353"></a><span class="c">!   #define SUPR ( indx&lt;20632 ? Q[indx++] : refill() )</span>
<a name="ln-354"></a><span class="c">!   #define KISS SUPR+CNG+XS</span>
<a name="ln-355"></a><span class="c">!</span>
<a name="ln-356"></a><span class="c">!   unsigned long long refill( )</span>
<a name="ln-357"></a><span class="c">!   {int i; unsigned long long z,h;</span>
<a name="ln-358"></a><span class="c">!   for(i=0;i&lt;20632;i++){ h=(carry&amp;1);</span>
<a name="ln-359"></a><span class="c">!   z=((Q&lt;&lt;41)&gt;&gt;1)+((Q&lt;&lt;39)&gt;&gt;1)+(carry&gt;&gt;1);</span>
<a name="ln-360"></a><span class="c">!   carry=(Q&gt;&gt;23)+(Q&gt;&gt;25)+(z&gt;&gt;63);</span>
<a name="ln-361"></a><span class="c">!   Q=~((z&lt;&lt;1)+h); }</span>
<a name="ln-362"></a><span class="c">!   indx=1; return (Q[0]);</span>
<a name="ln-363"></a><span class="c">!   }</span>
<a name="ln-364"></a><span class="c">!</span>
<a name="ln-365"></a><span class="c">!   int main()</span>
<a name="ln-366"></a><span class="c">!   {int i; unsigned long long x;</span>
<a name="ln-367"></a><span class="c">!   for(i=0;i&lt;20632;i++) Q=CNG+XS;</span>
<a name="ln-368"></a><span class="c">!   for(i=0;i&lt;1000000000;i++) x=KISS;</span>
<a name="ln-369"></a><span class="c">!   printf(&quot;Does x=4013566000157423768\n x=%LLd.\n&quot;,x);</span>
<a name="ln-370"></a><span class="c">!   }</span>
<a name="ln-371"></a><span class="c">!   ---------------------------------------------------------</span>
<a name="ln-372"></a><span class="c">!</span>
<a name="ln-373"></a><span class="c">!   Here is SUPRKISS32.c, the immense-period 32-bit RNG. I</span>
<a name="ln-374"></a><span class="c">!   invite you to cut, paste, compile and run to see if you</span>
<a name="ln-375"></a><span class="c">!   get the result I do. It should take around 10 seconds.</span>
<a name="ln-376"></a><span class="c">!   ---------------------------------------------------------</span>
<a name="ln-377"></a><span class="c">!   /*suprkiss64.c</span>
<a name="ln-378"></a><span class="c">!   b=2^64; x[n]=(b-1)-[(2^41+2^39)*x[n-20632]+carry mod b]</span>
<a name="ln-379"></a><span class="c">!   period 5*2^1320480&gt;10^397505</span>
<a name="ln-380"></a><span class="c">!   This version of SUPRKISS does not use t=a*x+c in 128 bits,</span>
<a name="ln-381"></a><span class="c">!   but uses only 64-bit stuff, takes 20 nanos versus 7.5 for</span>
<a name="ln-382"></a><span class="c">!   the 32-bit unsigned long long t=a*x+c version.</span>
<a name="ln-383"></a><span class="c">!   */</span>
<a name="ln-384"></a><span class="c">!</span>
<a name="ln-385"></a><span class="c">!   /* SUPRKISS64.c, period 5*2^1320480*(2^64-1) */</span>
<a name="ln-386"></a><span class="c">!   #include &lt;stdio.h&gt;</span>
<a name="ln-387"></a><span class="c">!   static unsigned long long Q[20632],carry=36243678541LL,</span>
<a name="ln-388"></a><span class="c">!   xcng=12367890123456LL,xs=521288629546311LL,indx=20632;</span>
<a name="ln-389"></a><span class="c">!</span>
<a name="ln-390"></a><span class="c">!   #define CNG ( xcng=6906969069LL*xcng+123 )</span>
<a name="ln-391"></a><span class="c">!   #define XS ( xs^=xs&lt;&lt;13,xs^=xs&gt;&gt;17,xs^=xs&lt;&lt;43 )</span>
<a name="ln-392"></a><span class="c">!   #define SUPR ( indx&lt;20632 ? Q[indx++] : refill() )</span>
<a name="ln-393"></a><span class="c">!   #define KISS SUPR+CNG+XS</span>
<a name="ln-394"></a><span class="c">!</span>
<a name="ln-395"></a><span class="c">!   unsigned long long refill( )</span>
<a name="ln-396"></a><span class="c">!   {int i; unsigned long long z,h;</span>
<a name="ln-397"></a><span class="c">!   for(i=0;i&lt;20632;i++){ h=(carry&amp;1);</span>
<a name="ln-398"></a><span class="c">!   z=((Q&lt;&lt;41)&gt;&gt;1)+((Q&lt;&lt;39)&gt;&gt;1)+(carry&gt;&gt;1);</span>
<a name="ln-399"></a><span class="c">!   carry=(Q&gt;&gt;23)+(Q&gt;&gt;25)+(z&gt;&gt;63);</span>
<a name="ln-400"></a><span class="c">!   Q=~((z&lt;&lt;1)+h); }</span>
<a name="ln-401"></a><span class="c">!   indx=1; return (Q[0]);</span>
<a name="ln-402"></a><span class="c">!   }</span>
<a name="ln-403"></a><span class="c">!</span>
<a name="ln-404"></a><span class="c">!   int main()</span>
<a name="ln-405"></a><span class="c">!   {int i; unsigned long long x;</span>
<a name="ln-406"></a><span class="c">!   for(i=0;i&lt;20632;i++) Q=CNG+XS;</span>
<a name="ln-407"></a><span class="c">!   for(i=0;i&lt;1000000000;i++) x=KISS;</span>
<a name="ln-408"></a><span class="c">!   printf(&quot;Does x=4013566000157423768\n x=%LLd.\n&quot;,x);</span>
<a name="ln-409"></a><span class="c">!   }</span>
<a name="ln-410"></a><span class="c">!</span>
<a name="ln-411"></a><span class="c">!   -----------------------------------------------------------</span>
<a name="ln-412"></a><span class="c">!</span>
<a name="ln-413"></a><span class="c">!   And here are equivalent Fortran versions, which, absent</span>
<a name="ln-414"></a><span class="c">!   C&#39;s inline features, seem to need ~10% more run time.</span>
<a name="ln-415"></a><span class="c">!</span>
<a name="ln-416"></a><span class="c">!   -----------------------------------------------------------</span>
<a name="ln-417"></a><span class="c">!   module suprkiss64_M ! period 5*2^1320480*(2^64-1)</span>
<a name="ln-418"></a><span class="c">!   integer,parameter :: I8=selected_int_kind(18)</span>
<a name="ln-419"></a><span class="c">!   integer(I8) :: Q(20632),carry=36243678541_I8, &amp;</span>
<a name="ln-420"></a><span class="c">!   xcng=12367890123456_I8,xs=521288629546311_I8,indx=20633_I8</span>
<a name="ln-421"></a><span class="c">!   contains</span>
<a name="ln-422"></a><span class="c">!   function KISS64() result(x)</span>
<a name="ln-423"></a><span class="c">!   integer(I8) :: x</span>
<a name="ln-424"></a><span class="c">!   if(indx &lt;= 20632)then; x=Q(indx); indx=indx+1</span>
<a name="ln-425"></a><span class="c">!   else; x=refill(); endif</span>
<a name="ln-426"></a><span class="c">!   xcng=xcng*6906969069_I8+123</span>
<a name="ln-427"></a><span class="c">!   xs=ieor(xs,ishft(xs,13))</span>
<a name="ln-428"></a><span class="c">!   xs=ieor(xs,ishft(xs,-17))</span>
<a name="ln-429"></a><span class="c">!   xs=ieor(xs,ishft(xs,43))</span>
<a name="ln-430"></a><span class="c">!   x=x+xcng+xs</span>
<a name="ln-431"></a><span class="c">!   return; end function KISS64</span>
<a name="ln-432"></a><span class="c">!</span>
<a name="ln-433"></a><span class="c">!   function refill() result(s)</span>
<a name="ln-434"></a><span class="c">!   integer(I8) :: i,s,z,h</span>
<a name="ln-435"></a><span class="c">!   do i=1,20632</span>
<a name="ln-436"></a><span class="c">!   h=iand(carry,1_I8)</span>
<a name="ln-437"></a><span class="c">!   z = ishft(ishft(Q(i),41),-1)+ &amp;</span>
<a name="ln-438"></a><span class="c">!   ishft(ishft(Q(i),39),-1)+ &amp;</span>
<a name="ln-439"></a><span class="c">!   ishft(carry,-1)</span>
<a name="ln-440"></a><span class="c">!   carry=ishft(Q(i),-23)+ishft(Q(i),-25)+ishft(z,-63)</span>
<a name="ln-441"></a><span class="c">!   Q(i)=not(ishft(z,1)+h)</span>
<a name="ln-442"></a><span class="c">!   end do</span>
<a name="ln-443"></a><span class="c">!   indx=2; s=Q(1)</span>
<a name="ln-444"></a><span class="c">!   return; end function refill</span>
<a name="ln-445"></a><span class="c">!</span>
<a name="ln-446"></a><span class="c">!   end module suprkiss64_M</span>
<a name="ln-447"></a><span class="c">!</span>
<a name="ln-448"></a><span class="c">!   program testKISS64</span>
<a name="ln-449"></a><span class="c">!   use suprkiss64_M</span>
<a name="ln-450"></a><span class="c">!   integer(I8) :: i,x</span>
<a name="ln-451"></a><span class="c">!   do i=1,20632 !fill Q with Congruential+Xorshift</span>
<a name="ln-452"></a><span class="c">!   xcng=xcng*6906969069_I8+123</span>
<a name="ln-453"></a><span class="c">!   xs=ieor(xs,ishft(xs,13))</span>
<a name="ln-454"></a><span class="c">!   xs=ieor(xs,ishft(xs,-17))</span>
<a name="ln-455"></a><span class="c">!   xs=ieor(xs,ishft(xs,43))</span>
<a name="ln-456"></a><span class="c">!   Q(i)=xcng+xs</span>
<a name="ln-457"></a><span class="c">!   end do</span>
<a name="ln-458"></a><span class="c">!   do i=1,1000000000_I8; x=KISS64(); end do</span>
<a name="ln-459"></a><span class="c">!   write(*,10) x</span>
<a name="ln-460"></a><span class="c">!   10 format(&#39; Does x = 4013566000157423768 ?&#39;,/,6x,&#39;x = &#39;,I20)</span>
<a name="ln-461"></a><span class="c">!   end program testKISS64</span>
<a name="ln-462"></a><span class="c">!   -------------------------------------------------------------</span>
<a name="ln-463"></a><span class="c">!</span>
<a name="ln-464"></a><span class="c">!   module suprkiss32_M ! period 5*2^1320481*(2^32-1)</span>
<a name="ln-465"></a><span class="c">!   integer,parameter :: I4=selected_int_kind(9)</span>
<a name="ln-466"></a><span class="c">!   integer(I4) :: Q(41265),carry=362_I4, &amp;</span>
<a name="ln-467"></a><span class="c">!   xcng=1236789_I4,xs=521288629_I4,indx=41266_I4</span>
<a name="ln-468"></a><span class="c">!   contains</span>
<a name="ln-469"></a><span class="c">!   function KISS32() result(x)</span>
<a name="ln-470"></a><span class="c">!   integer(I4):: x</span>
<a name="ln-471"></a><span class="c">!   if(indx &lt;= 41265)then;x=Q(indx); indx=indx+1</span>
<a name="ln-472"></a><span class="c">!   else; x=refill(); endif</span>
<a name="ln-473"></a><span class="c">!   xcng=xcng*69069_I4+123</span>
<a name="ln-474"></a><span class="c">!   xs=ieor(xs,ishft(xs,13))</span>
<a name="ln-475"></a><span class="c">!   xs=ieor(xs,ishft(xs,-17));</span>
<a name="ln-476"></a><span class="c">!   xs=ieor(xs,ishft(xs,5))</span>
<a name="ln-477"></a><span class="c">!   x=x+xcng+xs</span>
<a name="ln-478"></a><span class="c">!   return; end function KISS32</span>
<a name="ln-479"></a><span class="c">!</span>
<a name="ln-480"></a><span class="c">!   function refill() result(s)</span>
<a name="ln-481"></a><span class="c">!   integer(I4) :: i,s,z,h</span>
<a name="ln-482"></a><span class="c">!   do i = 1,41265</span>
<a name="ln-483"></a><span class="c">!   h = iand(carry,1_I4)</span>
<a name="ln-484"></a><span class="c">!   z = ishft(ishft(Q(i),9),-1)+ &amp;</span>
<a name="ln-485"></a><span class="c">!   ishft(ishft(Q(i),7),-1)+ &amp;</span>
<a name="ln-486"></a><span class="c">!   ishft(carry,-1)</span>
<a name="ln-487"></a><span class="c">!   carry=ishft(Q(i),-23)+ishft(Q(i),-25)+ishft(z,-31)</span>
<a name="ln-488"></a><span class="c">!   Q(i)=not(ishft(z,1)+h)</span>
<a name="ln-489"></a><span class="c">!   end do</span>
<a name="ln-490"></a><span class="c">!   indx=2; s=Q(1)</span>
<a name="ln-491"></a><span class="c">!   return; end function refill</span>
<a name="ln-492"></a><span class="c">!</span>
<a name="ln-493"></a><span class="c">!   end module suprkiss32_M</span>
<a name="ln-494"></a><span class="c">!</span>
<a name="ln-495"></a><span class="c">!   program testKISS32</span>
<a name="ln-496"></a><span class="c">!   use suprkiss32_M</span>
<a name="ln-497"></a><span class="c">!   integer(I4) :: i,x</span>
<a name="ln-498"></a><span class="c">!   do i=1,41265 !fill Q with Congruential+Xorshift</span>
<a name="ln-499"></a><span class="c">!   xcng=xcng*69069_I4+123</span>
<a name="ln-500"></a><span class="c">!   xs=ieor(xs,ishft(xs,13))</span>
<a name="ln-501"></a><span class="c">!   xs=ieor(xs,ishft(xs,-17))</span>
<a name="ln-502"></a><span class="c">!   xs=ieor(xs,ishft(xs,5))</span>
<a name="ln-503"></a><span class="c">!   Q(i)=xcng+xs</span>
<a name="ln-504"></a><span class="c">!   end do</span>
<a name="ln-505"></a><span class="c">!   do i=1,1000000000_I4; x=KISS32(); end do</span>
<a name="ln-506"></a><span class="c">!   write(*,10) x</span>
<a name="ln-507"></a><span class="c">!   10 format(&#39; Does x = 1809478889 ?&#39;,/,6x,&#39;x =&#39;,I11)</span>
<a name="ln-508"></a><span class="c">!   end program testKISS32</span>
<a name="ln-509"></a><span class="c">!</span>
<a name="ln-510"></a><span class="c">!   ---------------------------------------------------------------</span>
<a name="ln-511"></a><span class="c">!</span>
<a name="ln-512"></a><span class="c">!</span>
<a name="ln-513"></a><span class="c">! geo, Nov 27, 2009</span>
<a name="ln-514"></a><span class="c">! #1</span>
<a name="ln-515"></a>
<a name="ln-516"></a><span class="c">!-------------------------------------------------------------------------------</span>
<a name="ln-517"></a>
<a name="ln-518"></a>  <span class="k">function </span><span class="n">kiss64_uniform_rng</span><span class="p">()</span>                     <span class="k">result</span><span class="p">(</span><span class="n">unif</span><span class="p">)</span>
<a name="ln-519"></a>
<a name="ln-520"></a>    <span class="kt">real</span> <span class="p">(</span><span class="n">R8</span><span class="p">)</span>      <span class="kd">::</span> <span class="n">unif</span>
<a name="ln-521"></a>
<a name="ln-522"></a>    <span class="c">! [ LOCALS ]</span>
<a name="ln-523"></a>    <span class="kt">integer</span> <span class="p">(</span><span class="n">I8</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">x</span>
<a name="ln-524"></a>
<a name="ln-525"></a>    <span class="n">x</span> <span class="o">=</span> <span class="n">kiss64_rng</span><span class="p">()</span>
<a name="ln-526"></a>    <span class="n">unif</span> <span class="o">=</span> <span class="p">(</span> <span class="kt">real</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R8</span><span class="p">)</span> <span class="o">-</span> <span class="kt">real</span><span class="p">(</span><span class="n">I8_min</span><span class="p">,</span> <span class="n">R8</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="n">I16_range</span>
<a name="ln-527"></a>
<a name="ln-528"></a>  <span class="k">end function </span><span class="n">kiss64_uniform_rng</span>
<a name="ln-529"></a>
<a name="ln-530"></a><span class="c">!-------------------------------------------------------------------------------</span>
<a name="ln-531"></a>
<a name="ln-532"></a>  <span class="k">function </span><span class="n">kiss64_rng</span><span class="p">()</span>                             <span class="k">result</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<a name="ln-533"></a>
<a name="ln-534"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span>
<a name="ln-535"></a>    <span class="k">if</span><span class="p">(</span><span class="n">indx</span> <span class="o">&lt;=</span> <span class="mi">20632</span><span class="p">)</span> <span class="k">then</span>
<a name="ln-536"></a><span class="k">      </span><span class="n">x</span><span class="o">=</span><span class="n">Q</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
<a name="ln-537"></a>      <span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="o">+</span><span class="mi">1</span>
<a name="ln-538"></a>    <span class="k">else</span>
<a name="ln-539"></a><span class="k">      </span><span class="n">x</span><span class="o">=</span><span class="n">refill</span><span class="p">()</span>
<a name="ln-540"></a>    <span class="n">endif</span>
<a name="ln-541"></a>    <span class="n">xcng</span> <span class="o">=</span> <span class="n">xcng</span> <span class="o">*</span> <span class="mi">6906969069_I8</span><span class="o">+</span><span class="mi">123</span>
<a name="ln-542"></a>    <span class="n">xs</span> <span class="o">=</span> <span class="nb">ieor</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="nb">ishft</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="mi">13</span><span class="p">))</span>
<a name="ln-543"></a>    <span class="n">xs</span> <span class="o">=</span> <span class="nb">ieor</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="nb">ishft</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="o">-</span><span class="mi">17</span><span class="p">))</span>
<a name="ln-544"></a>    <span class="n">xs</span> <span class="o">=</span> <span class="nb">ieor</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="nb">ishft</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="mi">43</span><span class="p">))</span>
<a name="ln-545"></a>    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xcng</span> <span class="o">+</span> <span class="n">xs</span>
<a name="ln-546"></a>
<a name="ln-547"></a>  <span class="k">end function </span><span class="n">kiss64_rng</span>
<a name="ln-548"></a>
<a name="ln-549"></a><span class="c">!-------------------------------------------------------------------------------</span>
<a name="ln-550"></a>
<a name="ln-551"></a>  <span class="k">subroutine </span><span class="n">initialize_kiss_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<a name="ln-552"></a>
<a name="ln-553"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">),</span> <span class="k">optional</span>    <span class="kd">::</span> <span class="n">seed</span>
<a name="ln-554"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span>              <span class="kd">::</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span>
<a name="ln-555"></a>
<a name="ln-556"></a>    <span class="k">do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">20632</span> <span class="c">!fill Q with Congruential+Xorshift</span>
<a name="ln-557"></a>      <span class="n">xcng</span><span class="o">=</span><span class="n">xcng</span><span class="o">*</span><span class="mi">6906969069_I8</span><span class="o">+</span><span class="mi">123</span>
<a name="ln-558"></a>      <span class="n">xs</span><span class="o">=</span><span class="nb">ieor</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="nb">ishft</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="mi">13</span><span class="p">))</span>
<a name="ln-559"></a>      <span class="n">xs</span><span class="o">=</span><span class="nb">ieor</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="nb">ishft</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="o">-</span><span class="mi">17</span><span class="p">))</span>
<a name="ln-560"></a>      <span class="n">xs</span><span class="o">=</span><span class="nb">ieor</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="nb">ishft</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="mi">43</span><span class="p">))</span>
<a name="ln-561"></a>      <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">xcng</span><span class="o">+</span><span class="n">xs</span>
<a name="ln-562"></a>    <span class="k">end do</span>
<a name="ln-563"></a>
<a name="ln-564"></a><span class="k">    if</span> <span class="p">(</span> <span class="nb">present</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<a name="ln-565"></a>
<a name="ln-566"></a>      <span class="c">! &#39;seed&#39; simply specifies where in our long string of pseudo-random</span>
<a name="ln-567"></a>      <span class="c">! numbers we begin; basically generating and throwing away the first &#39;seed&#39; number</span>
<a name="ln-568"></a>      <span class="c">! of pseudo-random numbers</span>
<a name="ln-569"></a>      <span class="k">do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span>
<a name="ln-570"></a>        <span class="n">x</span> <span class="o">=</span> <span class="n">kiss64_rng</span><span class="p">()</span>
<a name="ln-571"></a>      <span class="n">enddo</span>
<a name="ln-572"></a>
<a name="ln-573"></a>    <span class="n">endif</span>
<a name="ln-574"></a>
<a name="ln-575"></a>  <span class="k">end subroutine </span><span class="n">initialize_kiss_rng</span>
<a name="ln-576"></a>
<a name="ln-577"></a><span class="c">!-------------------------------------------------------------------------------</span>
<a name="ln-578"></a>
<a name="ln-579"></a>  <span class="k">function </span><span class="n">refill</span><span class="p">()</span>                                 <span class="k">result</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<a name="ln-580"></a>    <span class="kt">integer</span><span class="p">(</span><span class="n">I8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">h</span>
<a name="ln-581"></a>    <span class="k">do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20632</span>
<a name="ln-582"></a>      <span class="n">h</span><span class="o">=</span><span class="nb">iand</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span><span class="mi">1_I8</span><span class="p">)</span>
<a name="ln-583"></a>      <span class="n">z</span> <span class="o">=</span> <span class="nb">ishft</span><span class="p">(</span><span class="nb">ishft</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">41</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                                             <span class="p">&amp;</span>
<a name="ln-584"></a>          <span class="o">+</span> <span class="nb">ishft</span><span class="p">(</span><span class="nb">ishft</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">39</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                                           <span class="p">&amp;</span>
<a name="ln-585"></a>          <span class="o">+</span> <span class="nb">ishft</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<a name="ln-586"></a>      <span class="n">carry</span><span class="o">=</span><span class="nb">ishft</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span><span class="o">+</span><span class="nb">ishft</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="o">-</span><span class="mi">25</span><span class="p">)</span><span class="o">+</span><span class="nb">ishft</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="mi">63</span><span class="p">)</span>
<a name="ln-587"></a>      <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="nb">not</span><span class="p">(</span><span class="nb">ishft</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="p">)</span>
<a name="ln-588"></a>    <span class="k">end do</span>
<a name="ln-589"></a><span class="k">    </span><span class="n">indx</span><span class="o">=</span><span class="mi">2</span>
<a name="ln-590"></a>    <span class="n">s</span><span class="o">=</span><span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<a name="ln-591"></a>
<a name="ln-592"></a>  <span class="k">end function </span><span class="n">refill</span>
<a name="ln-593"></a>
<a name="ln-594"></a><span class="k">end module </span><span class="n">kiss_random_number_generator</span>
</pre></div>

    </section>
    </div>
  </div>

  
    <hr>
  </div> <!-- /container -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-2">
          <p>&copy; 2019 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
            </p>
        </div>
        <div class="col-4">
          <p class="text-right"><small>
            Documentation for SWB2
               (version 2.0, build 96) generated by
            <a href="https://github.com/cmacmackin/ford">FORD</a>
             on Tue Sep  3 16:54:50 2019 </small>
          </p>
        </div>
        <div class="col">
          <p class="text-center"> SWB2 was developed by Steve Westenbroek, John Engott, Vic Kelson, Randall Hunt</p>
        </div>
      </div>
      <br>
    </div> <!-- /container -->
  </footer>

  <!-- Bootstrap core JavaScript
    ================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
  <script src="../js/bootstrap.min.js"></script>

  <!-- MathJax JavaScript
    ================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
  

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  

</body>

</html>